esphome:
  name: sprinklercomputer
  comment: "🌱 Automatisches Bewässerungssystem"

esp32:
  board: esp32dev

# WiFi Konfiguration
wifi:
  ssid: "abc"
  password: "abc"
  ap:
    ssid: "Sprinkler Fallback"
    password: "fallback123"

# Web Server
web_server:
  port: 80
  auth:
    username: root
    password: abc

# API und Updates
api:
ota:
  platform: esphome

# Logging (erweitert)
logger:
  level: INFO
  logs:
    component: WARN
    wifi: INFO
    ota: INFO
    api: INFO
    web_server: INFO
    switch: INFO
    sensor: WARN
    text_sensor: WARN
    script: INFO
    lambda: INFO
    scheduler: WARN

# Zeitgesteuerte Automatik
time:
  - platform: sntp
    id: sntp_time
    timezone: Europe/Berlin
    servers:
      - 0.pool.ntp.org
      - 1.pool.ntp.org

# Globale Variablen (vereinfacht)
globals:
  - id: sequential_running
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: current_valve_index
    type: int
    restore_value: false
    initial_value: '0'
  - id: last_watering_day
    type: int
    restore_value: true
    initial_value: '0'
  - id: rain_pause_active
    type: bool
    restore_value: true
    initial_value: 'false'
  - id: rain_pause_start_day
    type: int
    restore_value: true
    initial_value: '0'
  - id: last_watering_1
    type: int
    restore_value: true
    initial_value: '0'
  - id: last_watering_2
    type: int
    restore_value: true
    initial_value: '0'
  - id: last_watering_3
    type: int
    restore_value: true
    initial_value: '0'

# Status LED (intern)
light:
  - platform: status_led
    name: "System Status LED"
    restore_mode: ALWAYS_ON
    pin: GPIO23
    internal: true

# 🚿 BEWÄSSERUNGSVENTILE (alphabetisch für Web-Interface)
switch:
  # Gruppe A: Sprinkler-Anlagen
  - platform: gpio
    pin: GPIO32
    name: "A1 💦 Sprinkler Eingang (3x)"
    id: valve_0
    icon: "mdi:sprinkler-variant"
    device_class: switch
    entity_category: ""
    
  - platform: gpio
    pin: GPIO33
    name: "A2 💦 Sprinkler Trampolin + Hortensie"
    id: valve_1
    icon: "mdi:sprinkler-variant"
    device_class: switch
    entity_category: ""

  - platform: gpio
    pin: GPIO25
    name: "A3 💦 Sprinkler Grill + Kirschbäume"
    id: valve_2
    icon: "mdi:sprinkler-variant"
    device_class: switch
    entity_category: ""

  # Gruppe B: 💧 Tröpfchen-Bewässerung
  - platform: gpio
    pin: GPIO26
    name: "B1 💧 Tröpfchen Bereich Rechts"
    id: valve_3
    icon: "mdi:water-outline"
    device_class: switch
    entity_category: ""

  - platform: gpio
    pin: GPIO27
    name: "B2 💧 Tröpfchen Bereich Links"
    id: valve_4
    icon: "mdi:water-outline"
    device_class: switch
    entity_category: ""

  # Gruppe E:  Regenpause Toggle
  - platform: template
    name: "E2 🌧️ Regenpause"
    id: rain_pause_switch
    icon: "mdi:weather-rainy"
    device_class: switch
    entity_category: ""
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    lambda: |-
      return id(rain_pause_active);
    turn_on_action:
      - script.execute: activate_rain_pause
    turn_off_action:
      - script.execute: deactivate_rain_pause

# ⏰ ZEITSTEUERUNG
number:
  - platform: template
    name: "C1 ⏰ Startzeit → Stunde"
    id: start_hour
    min_value: 0
    max_value: 23
    step: 1
    initial_value: 6
    icon: "mdi:clock-time-four-outline"
    restore_value: true
    entity_category: config
    optimistic: true
    
  - platform: template
    name: "C2 ⏰ Startzeit → Minute"
    id: start_minute
    min_value: 0
    max_value: 59
    step: 1
    initial_value: 0
    icon: "mdi:clock-time-four-outline"
    restore_value: true
    entity_category: config
    optimistic: true
    
  - platform: template
    name: "C3 ¹²³ Bewässerung alle X Tage"
    id: watering_interval
    min_value: 1
    max_value: 7
    step: 1
    initial_value: 1
    icon: "mdi:calendar-range"
    restore_value: true
    entity_category: config
    optimistic: true

  # ⏱️ VENTIL-LAUFZEITEN
  - platform: template
    name: "D1 ⏱️ Sprinkler Eingang (Minuten)"
    id: valve_0_duration
    min_value: 1
    max_value: 60
    step: 1
    initial_value: 20
    icon: "mdi:timer-outline"
    restore_value: true
    entity_category: config
    optimistic: true

  - platform: template
    name: "D2 ⏱️ Sprinkler Trampolin (Minuten)"
    id: valve_1_duration
    min_value: 1
    max_value: 60
    step: 1
    initial_value: 25
    icon: "mdi:timer-outline"
    restore_value: true
    entity_category: config
    optimistic: true

  - platform: template
    name: "D3 ⏱️ Sprinkler Grill (Minuten)"
    id: valve_2_duration
    min_value: 1
    max_value: 60
    step: 1
    initial_value: 15
    icon: "mdi:timer-outline"
    restore_value: true
    entity_category: config
    optimistic: true

  - platform: template
    name: "D4 ⏱️ Tröpfchen Rechts (Minuten)"
    id: valve_3_duration
    min_value: 1
    max_value: 60
    step: 1
    initial_value: 45
    icon: "mdi:timer-outline"
    restore_value: true
    entity_category: config
    optimistic: true

  - platform: template
    name: "D5 ⏱️ Tröpfchen Links (Minuten)"
    id: valve_4_duration
    min_value: 1
    max_value: 60
    step: 1
    initial_value: 45
    icon: "mdi:timer-outline"
    restore_value: true
    entity_category: config
    optimistic: true

  #  REGENPAUSE
  - platform: template
    name: "E1 🌧⏸️ Regenpause Dauer (Tage)"
    id: rain_pause_duration
    min_value: 1
    max_value: 7
    step: 1
    initial_value: 2
    icon: "mdi:weather-rainy"
    restore_value: true
    entity_category: config
    optimistic: true

# 🎮 STEUERUNG & KONTROLLE
button:
  - platform: template
    name: "F1 ▶️ Sequenz JETZT Starten"
    icon: "mdi:play-circle" 
    on_press:
      - script.execute: start_sequence

  - platform: template
    name: "F2 ⏹️ Sequenz STOPPEN"
    icon: "mdi:stop-circle"
    on_press:
      - script.execute: stop_sequence

  - platform: template
    name: "G1 🛑 NOT-AUS - Alle Ventile AUS"
    icon: "mdi:alert"
    on_press:
      - script.execute: emergency_stop

  - platform: restart
    name: "G2 🔄 System Neustart"
    icon: "mdi:restart"
    entity_category: diagnostic

# 📊 STATUS & INFORMATIONEN
text_sensor:
  - platform: template
    name: "H0 📅 Uhrzeit & Datum"
    icon: "mdi:calendar-clock"
    entity_category: diagnostic
    lambda: |-
      auto time = id(sntp_time).now();
      if (time.is_valid()) {
        const char* weekdays[] = {
          "Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"
        };
        char buffer[40];
        sprintf(buffer, "%s - %02d.%02d.%04d – %02d:%02d",
                weekdays[time.day_of_week],
                time.day_of_month,
                time.month,
                time.year,
                time.hour,
                time.minute);
        return {buffer};
      } else {
        return {"⏳ Zeit wird synchronisiert..."};
      }
    update_interval: 30s
  
  - platform: template
    name: "H1 Gesamtstatus"
    id: overall_status
    icon: "mdi:clipboard-list"
    update_interval: 10s
    lambda: |-
      // 1. Wenn gerade bewässert wird
      if (id(sequential_running)) {
        static const char* names[] = {
          "💦 Sprinkler Eingang",
          "💦 Sprinkler Trampolin",
          "💦 Sprinkler Grill",
          "💧 Tröpfchen Rechts",
          "💧 Tröpfchen Links"
        };
        int idx = id(current_valve_index);
        const char* which = (idx >= 0 && idx < 5)
          ? names[idx]
          : "Ventil unbekannt";
        return {"🚿 Aktuell: " + std::string(which)};
      }

      // 2. Wenn Regenpause aktiv
      if (id(rain_pause_active)) {
        auto t = id(sntp_time).now();
        if (!t.is_valid()) {
          return {"🌧️ Regenpause aktiv"};
        }
        int passed    = t.day_of_year - id(rain_pause_start_day);
        int remaining = (int)id(rain_pause_duration).state - passed;
        if (remaining > 0) {
          return {"🌧️ Regenpause – noch " + to_string(remaining) + " Tage"};
        } else {
          return {"🌧️ Regenpause endet heute"};
        }
      }

      // 3. Sonst: Tage bis zur nächsten Bewässerung
      {
        int raw = (int)id(next_watering).state;
        if (raw == -2) {
          return {"⏳ Zeit wird synchronisiert..."};
        } else if (raw == 0) {
          return {"🌱 Heute Bewässerung"};
        } else {
          return {"🕒 Nächste Bewässerung in " +
                  to_string(raw) + " Tag(en)"};
        }
      } 
      
  - platform: template
    name: "H2 ⏳ Letzte Bewässerungen"
    icon: "mdi:calendar-clock"
    lambda: |-
      auto time = id(sntp_time).now();
      if (!time.is_valid()) return {"⏳ Zeit wird synchronisiert..."};

      int today = time.day_of_year;
      int d[] = {id(last_watering_1), id(last_watering_2), id(last_watering_3)};
      std::vector<std::string> ago_texts;

      for (int i = 0; i < 3; i++) {
        if (d[i] > 0) {
          int delta = today - d[i];
          if (delta == 0) {
            ago_texts.push_back("heute");
          } else if (delta > 0) {
            ago_texts.push_back("vor " + to_string(delta) + " Tagen");
          }
        }
      }

      if (ago_texts.empty()) {
        return {"Noch keine Bewässerung erfolgt"};
      }

      std::string result = "";
      for (size_t i = 0; i < ago_texts.size(); i++) {
        result += ago_texts[i];
        if (i < ago_texts.size() - 1) result += ", ";
      }
      return {result};
    update_interval: 60s

  - platform: template
    name: "H4 ⏱️ Betriebszeit"
    icon: "mdi:clock-time-eight-outline"
    entity_category: diagnostic
    lambda: |-
      int seconds = (int)(id(uptime_sensor).state);
      int days = seconds / 86400;
      int hours = (seconds % 86400) / 3600;
      int minutes = (seconds % 3600) / 60;
       return {
        "🔧 " + to_string(days) + " Tage, " + 
        to_string(hours) + " Stunden, " + 
        to_string(minutes) + " Minuten"
      };
    update_interval: 60s
    
  - platform: wifi_info
    ip_address:
      name: "H5 🌐 IP-Adresse"
      icon: "mdi:ip-network-outline"
      entity_category: diagnostic
      
      
sensor:
  - platform: uptime
    id: uptime_sensor
    internal: true  # ← wird in Web-Oberflächen nicht angezeigt
    name: "⏱️ Betriebszeit"
    icon: "mdi:clock-outline"
    entity_category: diagnostic
    
    
  - platform: template
    name: "I1 📅 Tage bis nächste Bewässerung"
    id: next_watering
    internal: true  # ← wird in Web-Oberflächen nicht angezeigt
    icon: "mdi:calendar-clock"
    entity_category: ""
    lambda: |-
      if (id(rain_pause_active)) {
          auto time = id(sntp_time).now();
          if (!time.is_valid()) return -2;  // Zeit fehlt
    
          int rain_start_day = id(rain_pause_start_day);
          int rain_duration = (int)id(rain_pause_duration).state;
          int days_passed = time.day_of_year - rain_start_day;
          int days_remaining = rain_duration - days_passed;
          // Bei aktiver Regenpause: Rückgabe negativer Wert zur Unterscheidung
          return (days_remaining > 0) ? (-10 - days_remaining) : 0; 
      }

      auto time = id(sntp_time).now();
      if (!time.is_valid()) return -2;

      int current_day = time.day_of_year;
      int last_day = id(last_watering_day);
      int interval = (int)id(watering_interval).state;

      if (last_day == 0) return 0;

      int days_since = current_day - last_day;
      int days_until = interval - days_since;

      return (days_until <= 0) ? 0 : days_until;
    update_interval: 300s

  - platform: template
    name: "H3 ⏱️ Gesamtdauer Sequenz (Minuten)"
    id: total_sequence_time
    icon: "mdi:timer-sand"
    entity_category: diagnostic
    lambda: |-
      esphome::number::Number* durations[] = {id(valve_0_duration), id(valve_1_duration), id(valve_2_duration), id(valve_3_duration), id(valve_4_duration)};
      float total = 0;
      for (int i = 0; i < 5; i++) {
        total += durations[i]->state;
      }
      // +4 für die 5-Sekunden-Pausen zwischen Ventilen
      return total + (4.0 * 5.0 / 60.0);
    update_interval: 30s

# 🔧 SKRIPTE (Vereinfachte Logik)
script:
  - id: start_sequence
    then:
      - if:
          condition:
            - lambda: 'return !id(sequential_running);'
          then:
            - logger.log: "🚀 Starte Bewässerungssequenz"
            - script.execute: stop_all_valves
            - globals.set:
                id: sequential_running
                value: 'true'
            - globals.set:
                id: current_valve_index
                value: '0'

            # Aktualisiere die letzten 3 Bewässerungstage
            - lambda: |-
                id(last_watering_3) = id(last_watering_2);
                id(last_watering_2) = id(last_watering_1);
                auto time = id(sntp_time).now();
                if (time.is_valid()) {
                  id(last_watering_1) = time.day_of_year;
                  id(last_watering_day) = time.day_of_year;
                }

            - delay: 2s
            - script.execute: start_current_valve
          else:
            - logger.log: 
                format: "⚠️ Sequenz läuft bereits (Ventil %d)"
                args: [ 'id(current_valve_index)' ]


  - id: stop_sequence
    then:
      - logger.log: "🛑 Stoppe Bewässerungssequenz"
      - globals.set:
          id: sequential_running
          value: 'false'
      - globals.set:
          id: current_valve_index
          value: '0'
      - script.execute: stop_all_valves

  - id: emergency_stop
    then:
      - logger.log: "🚨 NOT-AUS aktiviert!"
      - script.execute: stop_sequence

  - id: stop_all_valves
    then:
      - logger.log: "🛑 Alle Ventile geschlossen"
      - switch.turn_off: valve_0
      - switch.turn_off: valve_1
      - switch.turn_off: valve_2
      - switch.turn_off: valve_3
      - switch.turn_off: valve_4

  - id: start_current_valve
    then:
      - logger.log:
           format: "💧 Ventil %d geöffnet"
           args: [ 'id(current_valve_index)' ]
      - lambda: |-
          esphome::switch_::Switch* valves[] = {id(valve_0), id(valve_1), id(valve_2), id(valve_3), id(valve_4)};
          esphome::number::Number* durations[] = {id(valve_0_duration), id(valve_1_duration), id(valve_2_duration), id(valve_3_duration), id(valve_4_duration)};
          std::string valve_names[] = {"Sprinkler Eingang", "Sprinkler Trampolin", "Sprinkler Grill", "Tröpfchen Links", "Tröpfchen Rechts"};
          
          int current_idx = id(current_valve_index);
          if (current_idx >= 0 && current_idx < 5) {
            ESP_LOGI("sequence", "💧 Starte Ventil %d: %s (%d Min)", 
                     current_idx, valve_names[current_idx].c_str(), (int)durations[current_idx]->state);
            valves[current_idx]->turn_on();
          }

  - id: next_valve
    then:
      - globals.set:
          id: current_valve_index
          value: !lambda 'return id(current_valve_index) + 1;'
      - lambda: |-
          int current_idx = id(current_valve_index);
          if (current_idx >= 5) {
            ESP_LOGI("sequence", "✅ Bewässerungssequenz erfolgreich abgeschlossen");
            id(stop_sequence).execute();
          } else {
            ESP_LOGI("sequence", "⏳ Pause 5s vor nächstem Ventil...");
          }
      - delay: 5s
      - if:
          condition:
            - lambda: 'return id(sequential_running) && id(current_valve_index) < 5;'
          then:
            - script.execute: start_current_valve

  - id: activate_rain_pause
    then:
      - logger.log: "🌧️ Regenpause aktiviert"
      - globals.set:
          id: rain_pause_active
          value: 'true'
      - lambda: |-
          auto time = id(sntp_time).now();
          if (time.is_valid()) {
            id(rain_pause_start_day) = time.day_of_year;
          }
      - script.execute: stop_sequence
      - component.update: overall_status
     

  - id: deactivate_rain_pause
    then:
      - logger.log: "☀️ Regenpause deaktiviert"
      - globals.set:
          id: rain_pause_active
          value: 'false'
      - globals.set:
          id: rain_pause_start_day
          value: '0'
      - component.update: overall_status
     
# ⏲️ TIMER & AUTOMATISCHE BEWÄSSERUNG
interval:
  # Timer für Ventil-Kontrolle (prüft alle 10 Sekunden)
  - interval: 10s
    id: valve_controller
    then:
      - lambda: |-
          if (!id(sequential_running)) return;
          
          esphome::switch_::Switch* valves[] = {id(valve_0), id(valve_1), id(valve_2), id(valve_3), id(valve_4)};
          esphome::number::Number* durations[] = {id(valve_0_duration), id(valve_1_duration), id(valve_2_duration), id(valve_3_duration), id(valve_4_duration)};
          
          int current_idx = id(current_valve_index);
          if (current_idx >= 0 && current_idx < 5) {
            auto current_valve = valves[current_idx];
            
            // Prüfen ob Ventil läuft und Zeit abgelaufen ist
            if (current_valve->state) {
              static unsigned long valve_start_times[5] = {0, 0, 0, 0, 0};
              
              // Startzeit beim ersten Mal setzen
              if (valve_start_times[current_idx] == 0) {
                valve_start_times[current_idx] = millis();
              }
              
              unsigned long elapsed = millis() - valve_start_times[current_idx];
              unsigned long target_duration = (unsigned long)(durations[current_idx]->state * 60 * 1000);
              
              if (elapsed >= target_duration) {
                ESP_LOGI("timer", "⏰ Timer für Ventil %d abgelaufen (%lu ms)", current_idx, elapsed);
                current_valve->turn_off();
                valve_start_times[current_idx] = 0; // Reset für nächsten Durchlauf
                id(next_valve).execute();
              }
            }
          }

  # 🤖 AUTOMATISCHE BEWÄSSERUNG (minütliche Prüfung)
  - interval: 60s
    id: auto_watering_check
    then:
      - lambda: |-
          if (id(sequential_running)) return;
          
          auto time = id(sntp_time).now();
          if (!time.is_valid()) return;
          
          int current_hour = time.hour;
          int current_minute = time.minute;
          int target_hour = (int)id(start_hour).state;
          int target_minute = (int)id(start_minute).state;
          
          // Prüfen ob es Zeit für die Bewässerung ist
          if (current_hour == target_hour && current_minute == target_minute) {
            int current_day = time.day_of_year;
            int last_day = id(last_watering_day);
            int interval = (int)id(watering_interval).state;
            
            // Regenpause prüfen
            if (id(rain_pause_active)) {
              int rain_start_day = id(rain_pause_start_day);
              int rain_duration = (int)id(rain_pause_duration).state;
              int rain_days_passed = current_day - rain_start_day;
              
              if (rain_days_passed >= rain_duration) {
                ESP_LOGI("rain", "☀️ Regenpause automatisch beendet nach %d Tagen", rain_days_passed);
                id(deactivate_rain_pause).execute();
              } else {
                ESP_LOGI("rain", "☔ Bewässerung übersprungen - Regenpause noch %d Tage aktiv", 
                         rain_duration - rain_days_passed);
                return;
              }
            }
            
            // Prüfen ob Bewässerung fällig ist
            if ((current_day - last_day) >= interval || last_day == 0) {
              ESP_LOGI("auto", "🌱 Starte automatische Bewässerung (alle %d Tage)", interval);
              id(last_watering_day) = current_day;
              id(start_sequence).execute();
            }
          }

# 🔮 ZUKÜNFTIGE ERWEITERUNGEN
# Für neue Ventile einfach hinzufügen:
#
# - platform: gpio
#   pin: GPIO14
#   name: "C1 💧 Gewächshaus"
#   id: valve_5
#   icon: "mdi:greenhouse"
#
# Dann in den Arrays die "5" auf "6" ändern - fertig!
