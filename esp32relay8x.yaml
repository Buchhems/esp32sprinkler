esphome:
  name: sprinklercomputer
  comment: "ğŸŒ± Automatisches BewÃ¤sserungssystem"

esp32:
  board: esp32dev

# WiFi Konfiguration
wifi:
  ssid: "abc"
  password: "abc"
  ap:
    ssid: "Sprinkler Fallback"
    password: "fallback123"

# Web Server
web_server:
  port: 80
  auth:
    username: root
    password: abc

# API und Updates
api:
ota:
  platform: esphome

# Logging (erweitert)
logger:
  level: INFO
  logs:
    component: WARN
    wifi: INFO
    ota: INFO
    api: INFO
    web_server: INFO
    switch: INFO
    sensor: WARN
    text_sensor: WARN
    script: INFO
    lambda: INFO
    scheduler: WARN

# Zeitgesteuerte Automatik
time:
  - platform: sntp
    id: sntp_time
    timezone: Europe/Berlin
    servers:
      - 0.pool.ntp.org
      - 1.pool.ntp.org

# Globale Variablen (vereinfacht)
globals:
  - id: sequential_running
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: current_valve_index
    type: int
    restore_value: false
    initial_value: '0'
  - id: last_watering_day
    type: int
    restore_value: true
    initial_value: '0'
  - id: rain_pause_active
    type: bool
    restore_value: true
    initial_value: 'false'
  - id: rain_pause_start_day
    type: int
    restore_value: true
    initial_value: '0'
  - id: last_watering_1
    type: int
    restore_value: true
    initial_value: '0'
  - id: last_watering_2
    type: int
    restore_value: true
    initial_value: '0'
  - id: last_watering_3
    type: int
    restore_value: true
    initial_value: '0'

# Status LED (intern)
light:
  - platform: status_led
    name: "System Status LED"
    restore_mode: ALWAYS_ON
    pin: GPIO23
    internal: true

# ğŸš¿ BEWÃ„SSERUNGSVENTILE (alphabetisch fÃ¼r Web-Interface)
switch:
  # Gruppe A: Sprinkler-Anlagen
  - platform: gpio
    pin: GPIO32
    name: "A1 ğŸ’¦ Sprinkler Eingang (3x)"
    id: valve_0
    icon: "mdi:sprinkler-variant"
    device_class: switch
    entity_category: ""
    
  - platform: gpio
    pin: GPIO33
    name: "A2 ğŸ’¦ Sprinkler Trampolin + Hortensie"
    id: valve_1
    icon: "mdi:sprinkler-variant"
    device_class: switch
    entity_category: ""

  - platform: gpio
    pin: GPIO25
    name: "A3 ğŸ’¦ Sprinkler Grill + KirschbÃ¤ume"
    id: valve_2
    icon: "mdi:sprinkler-variant"
    device_class: switch
    entity_category: ""

  # Gruppe B: ğŸ’§ TrÃ¶pfchen-BewÃ¤sserung
  - platform: gpio
    pin: GPIO26
    name: "B1 ğŸ’§ TrÃ¶pfchen Bereich Rechts"
    id: valve_3
    icon: "mdi:water-outline"
    device_class: switch
    entity_category: ""

  - platform: gpio
    pin: GPIO27
    name: "B2 ğŸ’§ TrÃ¶pfchen Bereich Links"
    id: valve_4
    icon: "mdi:water-outline"
    device_class: switch
    entity_category: ""

  # Gruppe E:  Regenpause Toggle
  - platform: template
    name: "E2 ğŸŒ§ï¸ Regenpause"
    id: rain_pause_switch
    icon: "mdi:weather-rainy"
    device_class: switch
    entity_category: ""
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    lambda: |-
      return id(rain_pause_active);
    turn_on_action:
      - script.execute: activate_rain_pause
    turn_off_action:
      - script.execute: deactivate_rain_pause

# â° ZEITSTEUERUNG
number:
  - platform: template
    name: "C1 â° Startzeit â†’ Stunde"
    id: start_hour
    min_value: 0
    max_value: 23
    step: 1
    initial_value: 6
    icon: "mdi:clock-time-four-outline"
    restore_value: true
    entity_category: config
    optimistic: true
    
  - platform: template
    name: "C2 â° Startzeit â†’ Minute"
    id: start_minute
    min_value: 0
    max_value: 59
    step: 1
    initial_value: 0
    icon: "mdi:clock-time-four-outline"
    restore_value: true
    entity_category: config
    optimistic: true
    
  - platform: template
    name: "C3 Â¹Â²Â³ BewÃ¤sserung alle X Tage"
    id: watering_interval
    min_value: 1
    max_value: 7
    step: 1
    initial_value: 1
    icon: "mdi:calendar-range"
    restore_value: true
    entity_category: config
    optimistic: true

  # â±ï¸ VENTIL-LAUFZEITEN
  - platform: template
    name: "D1 â±ï¸ Sprinkler Eingang (Minuten)"
    id: valve_0_duration
    min_value: 1
    max_value: 60
    step: 1
    initial_value: 20
    icon: "mdi:timer-outline"
    restore_value: true
    entity_category: config
    optimistic: true

  - platform: template
    name: "D2 â±ï¸ Sprinkler Trampolin (Minuten)"
    id: valve_1_duration
    min_value: 1
    max_value: 60
    step: 1
    initial_value: 25
    icon: "mdi:timer-outline"
    restore_value: true
    entity_category: config
    optimistic: true

  - platform: template
    name: "D3 â±ï¸ Sprinkler Grill (Minuten)"
    id: valve_2_duration
    min_value: 1
    max_value: 60
    step: 1
    initial_value: 15
    icon: "mdi:timer-outline"
    restore_value: true
    entity_category: config
    optimistic: true

  - platform: template
    name: "D4 â±ï¸ TrÃ¶pfchen Rechts (Minuten)"
    id: valve_3_duration
    min_value: 1
    max_value: 60
    step: 1
    initial_value: 45
    icon: "mdi:timer-outline"
    restore_value: true
    entity_category: config
    optimistic: true

  - platform: template
    name: "D5 â±ï¸ TrÃ¶pfchen Links (Minuten)"
    id: valve_4_duration
    min_value: 1
    max_value: 60
    step: 1
    initial_value: 45
    icon: "mdi:timer-outline"
    restore_value: true
    entity_category: config
    optimistic: true

  #  REGENPAUSE
  - platform: template
    name: "E1 ğŸŒ§â¸ï¸ Regenpause Dauer (Tage)"
    id: rain_pause_duration
    min_value: 1
    max_value: 7
    step: 1
    initial_value: 2
    icon: "mdi:weather-rainy"
    restore_value: true
    entity_category: config
    optimistic: true

# ğŸ® STEUERUNG & KONTROLLE
button:
  - platform: template
    name: "F1 â–¶ï¸ Sequenz JETZT Starten"
    icon: "mdi:play-circle" 
    on_press:
      - script.execute: start_sequence

  - platform: template
    name: "F2 â¹ï¸ Sequenz STOPPEN"
    icon: "mdi:stop-circle"
    on_press:
      - script.execute: stop_sequence

  - platform: template
    name: "G1 ğŸ›‘ NOT-AUS - Alle Ventile AUS"
    icon: "mdi:alert"
    on_press:
      - script.execute: emergency_stop

  - platform: restart
    name: "G2 ğŸ”„ System Neustart"
    icon: "mdi:restart"
    entity_category: diagnostic

# ğŸ“Š STATUS & INFORMATIONEN
text_sensor:
  - platform: template
    name: "H0 ğŸ“… Uhrzeit & Datum"
    icon: "mdi:calendar-clock"
    entity_category: diagnostic
    lambda: |-
      auto time = id(sntp_time).now();
      if (time.is_valid()) {
        const char* weekdays[] = {
          "Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"
        };
        char buffer[40];
        sprintf(buffer, "%s - %02d.%02d.%04d â€“ %02d:%02d",
                weekdays[time.day_of_week],
                time.day_of_month,
                time.month,
                time.year,
                time.hour,
                time.minute);
        return {buffer};
      } else {
        return {"â³ Zeit wird synchronisiert..."};
      }
    update_interval: 30s
  
  - platform: template
    name: "H1 Gesamtstatus"
    id: overall_status
    icon: "mdi:clipboard-list"
    update_interval: 10s
    lambda: |-
      // 1. Wenn gerade bewÃ¤ssert wird
      if (id(sequential_running)) {
        static const char* names[] = {
          "ğŸ’¦ Sprinkler Eingang",
          "ğŸ’¦ Sprinkler Trampolin",
          "ğŸ’¦ Sprinkler Grill",
          "ğŸ’§ TrÃ¶pfchen Rechts",
          "ğŸ’§ TrÃ¶pfchen Links"
        };
        int idx = id(current_valve_index);
        const char* which = (idx >= 0 && idx < 5)
          ? names[idx]
          : "Ventil unbekannt";
        return {"ğŸš¿ Aktuell: " + std::string(which)};
      }

      // 2. Wenn Regenpause aktiv
      if (id(rain_pause_active)) {
        auto t = id(sntp_time).now();
        if (!t.is_valid()) {
          return {"ğŸŒ§ï¸ Regenpause aktiv"};
        }
        int passed    = t.day_of_year - id(rain_pause_start_day);
        int remaining = (int)id(rain_pause_duration).state - passed;
        if (remaining > 0) {
          return {"ğŸŒ§ï¸ Regenpause â€“ noch " + to_string(remaining) + " Tage"};
        } else {
          return {"ğŸŒ§ï¸ Regenpause endet heute"};
        }
      }

      // 3. Sonst: Tage bis zur nÃ¤chsten BewÃ¤sserung
      {
        int raw = (int)id(next_watering).state;
        if (raw == -2) {
          return {"â³ Zeit wird synchronisiert..."};
        } else if (raw == 0) {
          return {"ğŸŒ± Heute BewÃ¤sserung"};
        } else {
          return {"ğŸ•’ NÃ¤chste BewÃ¤sserung in " +
                  to_string(raw) + " Tag(en)"};
        }
      } 
      
  - platform: template
    name: "H2 â³ Letzte BewÃ¤sserungen"
    icon: "mdi:calendar-clock"
    lambda: |-
      auto time = id(sntp_time).now();
      if (!time.is_valid()) return {"â³ Zeit wird synchronisiert..."};

      int today = time.day_of_year;
      int d[] = {id(last_watering_1), id(last_watering_2), id(last_watering_3)};
      std::vector<std::string> ago_texts;

      for (int i = 0; i < 3; i++) {
        if (d[i] > 0) {
          int delta = today - d[i];
          if (delta == 0) {
            ago_texts.push_back("heute");
          } else if (delta > 0) {
            ago_texts.push_back("vor " + to_string(delta) + " Tagen");
          }
        }
      }

      if (ago_texts.empty()) {
        return {"Noch keine BewÃ¤sserung erfolgt"};
      }

      std::string result = "";
      for (size_t i = 0; i < ago_texts.size(); i++) {
        result += ago_texts[i];
        if (i < ago_texts.size() - 1) result += ", ";
      }
      return {result};
    update_interval: 60s

  - platform: template
    name: "H4 â±ï¸ Betriebszeit"
    icon: "mdi:clock-time-eight-outline"
    entity_category: diagnostic
    lambda: |-
      int seconds = (int)(id(uptime_sensor).state);
      int days = seconds / 86400;
      int hours = (seconds % 86400) / 3600;
      int minutes = (seconds % 3600) / 60;
       return {
        "ğŸ”§ " + to_string(days) + " Tage, " + 
        to_string(hours) + " Stunden, " + 
        to_string(minutes) + " Minuten"
      };
    update_interval: 60s
    
  - platform: wifi_info
    ip_address:
      name: "H5 ğŸŒ IP-Adresse"
      icon: "mdi:ip-network-outline"
      entity_category: diagnostic
      
      
sensor:
  - platform: uptime
    id: uptime_sensor
    internal: true  # â† wird in Web-OberflÃ¤chen nicht angezeigt
    name: "â±ï¸ Betriebszeit"
    icon: "mdi:clock-outline"
    entity_category: diagnostic
    
    
  - platform: template
    name: "I1 ğŸ“… Tage bis nÃ¤chste BewÃ¤sserung"
    id: next_watering
    internal: true  # â† wird in Web-OberflÃ¤chen nicht angezeigt
    icon: "mdi:calendar-clock"
    entity_category: ""
    lambda: |-
      if (id(rain_pause_active)) {
          auto time = id(sntp_time).now();
          if (!time.is_valid()) return -2;  // Zeit fehlt
    
          int rain_start_day = id(rain_pause_start_day);
          int rain_duration = (int)id(rain_pause_duration).state;
          int days_passed = time.day_of_year - rain_start_day;
          int days_remaining = rain_duration - days_passed;
          // Bei aktiver Regenpause: RÃ¼ckgabe negativer Wert zur Unterscheidung
          return (days_remaining > 0) ? (-10 - days_remaining) : 0; 
      }

      auto time = id(sntp_time).now();
      if (!time.is_valid()) return -2;

      int current_day = time.day_of_year;
      int last_day = id(last_watering_day);
      int interval = (int)id(watering_interval).state;

      if (last_day == 0) return 0;

      int days_since = current_day - last_day;
      int days_until = interval - days_since;

      return (days_until <= 0) ? 0 : days_until;
    update_interval: 300s

  - platform: template
    name: "H3 â±ï¸ Gesamtdauer Sequenz (Minuten)"
    id: total_sequence_time
    icon: "mdi:timer-sand"
    entity_category: diagnostic
    lambda: |-
      esphome::number::Number* durations[] = {id(valve_0_duration), id(valve_1_duration), id(valve_2_duration), id(valve_3_duration), id(valve_4_duration)};
      float total = 0;
      for (int i = 0; i < 5; i++) {
        total += durations[i]->state;
      }
      // +4 fÃ¼r die 5-Sekunden-Pausen zwischen Ventilen
      return total + (4.0 * 5.0 / 60.0);
    update_interval: 30s

# ğŸ”§ SKRIPTE (Vereinfachte Logik)
script:
  - id: start_sequence
    then:
      - if:
          condition:
            - lambda: 'return !id(sequential_running);'
          then:
            - logger.log: "ğŸš€ Starte BewÃ¤sserungssequenz"
            - script.execute: stop_all_valves
            - globals.set:
                id: sequential_running
                value: 'true'
            - globals.set:
                id: current_valve_index
                value: '0'

            # Aktualisiere die letzten 3 BewÃ¤sserungstage
            - lambda: |-
                id(last_watering_3) = id(last_watering_2);
                id(last_watering_2) = id(last_watering_1);
                auto time = id(sntp_time).now();
                if (time.is_valid()) {
                  id(last_watering_1) = time.day_of_year;
                  id(last_watering_day) = time.day_of_year;
                }

            - delay: 2s
            - script.execute: start_current_valve
          else:
            - logger.log: 
                format: "âš ï¸ Sequenz lÃ¤uft bereits (Ventil %d)"
                args: [ 'id(current_valve_index)' ]


  - id: stop_sequence
    then:
      - logger.log: "ğŸ›‘ Stoppe BewÃ¤sserungssequenz"
      - globals.set:
          id: sequential_running
          value: 'false'
      - globals.set:
          id: current_valve_index
          value: '0'
      - script.execute: stop_all_valves

  - id: emergency_stop
    then:
      - logger.log: "ğŸš¨ NOT-AUS aktiviert!"
      - script.execute: stop_sequence

  - id: stop_all_valves
    then:
      - logger.log: "ğŸ›‘ Alle Ventile geschlossen"
      - switch.turn_off: valve_0
      - switch.turn_off: valve_1
      - switch.turn_off: valve_2
      - switch.turn_off: valve_3
      - switch.turn_off: valve_4

  - id: start_current_valve
    then:
      - logger.log:
           format: "ğŸ’§ Ventil %d geÃ¶ffnet"
           args: [ 'id(current_valve_index)' ]
      - lambda: |-
          esphome::switch_::Switch* valves[] = {id(valve_0), id(valve_1), id(valve_2), id(valve_3), id(valve_4)};
          esphome::number::Number* durations[] = {id(valve_0_duration), id(valve_1_duration), id(valve_2_duration), id(valve_3_duration), id(valve_4_duration)};
          std::string valve_names[] = {"Sprinkler Eingang", "Sprinkler Trampolin", "Sprinkler Grill", "TrÃ¶pfchen Links", "TrÃ¶pfchen Rechts"};
          
          int current_idx = id(current_valve_index);
          if (current_idx >= 0 && current_idx < 5) {
            ESP_LOGI("sequence", "ğŸ’§ Starte Ventil %d: %s (%d Min)", 
                     current_idx, valve_names[current_idx].c_str(), (int)durations[current_idx]->state);
            valves[current_idx]->turn_on();
          }

  - id: next_valve
    then:
      - globals.set:
          id: current_valve_index
          value: !lambda 'return id(current_valve_index) + 1;'
      - lambda: |-
          int current_idx = id(current_valve_index);
          if (current_idx >= 5) {
            ESP_LOGI("sequence", "âœ… BewÃ¤sserungssequenz erfolgreich abgeschlossen");
            id(stop_sequence).execute();
          } else {
            ESP_LOGI("sequence", "â³ Pause 5s vor nÃ¤chstem Ventil...");
          }
      - delay: 5s
      - if:
          condition:
            - lambda: 'return id(sequential_running) && id(current_valve_index) < 5;'
          then:
            - script.execute: start_current_valve

  - id: activate_rain_pause
    then:
      - logger.log: "ğŸŒ§ï¸ Regenpause aktiviert"
      - globals.set:
          id: rain_pause_active
          value: 'true'
      - lambda: |-
          auto time = id(sntp_time).now();
          if (time.is_valid()) {
            id(rain_pause_start_day) = time.day_of_year;
          }
      - script.execute: stop_sequence
      - component.update: overall_status
     

  - id: deactivate_rain_pause
    then:
      - logger.log: "â˜€ï¸ Regenpause deaktiviert"
      - globals.set:
          id: rain_pause_active
          value: 'false'
      - globals.set:
          id: rain_pause_start_day
          value: '0'
      - component.update: overall_status
     
# â²ï¸ TIMER & AUTOMATISCHE BEWÃ„SSERUNG
interval:
  # Timer fÃ¼r Ventil-Kontrolle (prÃ¼ft alle 10 Sekunden)
  - interval: 10s
    id: valve_controller
    then:
      - lambda: |-
          if (!id(sequential_running)) return;
          
          esphome::switch_::Switch* valves[] = {id(valve_0), id(valve_1), id(valve_2), id(valve_3), id(valve_4)};
          esphome::number::Number* durations[] = {id(valve_0_duration), id(valve_1_duration), id(valve_2_duration), id(valve_3_duration), id(valve_4_duration)};
          
          int current_idx = id(current_valve_index);
          if (current_idx >= 0 && current_idx < 5) {
            auto current_valve = valves[current_idx];
            
            // PrÃ¼fen ob Ventil lÃ¤uft und Zeit abgelaufen ist
            if (current_valve->state) {
              static unsigned long valve_start_times[5] = {0, 0, 0, 0, 0};
              
              // Startzeit beim ersten Mal setzen
              if (valve_start_times[current_idx] == 0) {
                valve_start_times[current_idx] = millis();
              }
              
              unsigned long elapsed = millis() - valve_start_times[current_idx];
              unsigned long target_duration = (unsigned long)(durations[current_idx]->state * 60 * 1000);
              
              if (elapsed >= target_duration) {
                ESP_LOGI("timer", "â° Timer fÃ¼r Ventil %d abgelaufen (%lu ms)", current_idx, elapsed);
                current_valve->turn_off();
                valve_start_times[current_idx] = 0; // Reset fÃ¼r nÃ¤chsten Durchlauf
                id(next_valve).execute();
              }
            }
          }

  # ğŸ¤– AUTOMATISCHE BEWÃ„SSERUNG (minÃ¼tliche PrÃ¼fung)
  - interval: 60s
    id: auto_watering_check
    then:
      - lambda: |-
          if (id(sequential_running)) return;
          
          auto time = id(sntp_time).now();
          if (!time.is_valid()) return;
          
          int current_hour = time.hour;
          int current_minute = time.minute;
          int target_hour = (int)id(start_hour).state;
          int target_minute = (int)id(start_minute).state;
          
          // PrÃ¼fen ob es Zeit fÃ¼r die BewÃ¤sserung ist
          if (current_hour == target_hour && current_minute == target_minute) {
            int current_day = time.day_of_year;
            int last_day = id(last_watering_day);
            int interval = (int)id(watering_interval).state;
            
            // Regenpause prÃ¼fen
            if (id(rain_pause_active)) {
              int rain_start_day = id(rain_pause_start_day);
              int rain_duration = (int)id(rain_pause_duration).state;
              int rain_days_passed = current_day - rain_start_day;
              
              if (rain_days_passed >= rain_duration) {
                ESP_LOGI("rain", "â˜€ï¸ Regenpause automatisch beendet nach %d Tagen", rain_days_passed);
                id(deactivate_rain_pause).execute();
              } else {
                ESP_LOGI("rain", "â˜” BewÃ¤sserung Ã¼bersprungen - Regenpause noch %d Tage aktiv", 
                         rain_duration - rain_days_passed);
                return;
              }
            }
            
            // PrÃ¼fen ob BewÃ¤sserung fÃ¤llig ist
            if ((current_day - last_day) >= interval || last_day == 0) {
              ESP_LOGI("auto", "ğŸŒ± Starte automatische BewÃ¤sserung (alle %d Tage)", interval);
              id(last_watering_day) = current_day;
              id(start_sequence).execute();
            }
          }

# ğŸ”® ZUKÃœNFTIGE ERWEITERUNGEN
# FÃ¼r neue Ventile einfach hinzufÃ¼gen:
#
# - platform: gpio
#   pin: GPIO14
#   name: "C1 ğŸ’§ GewÃ¤chshaus"
#   id: valve_5
#   icon: "mdi:greenhouse"
#
# Dann in den Arrays die "5" auf "6" Ã¤ndern - fertig!
